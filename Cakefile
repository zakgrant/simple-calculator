{exec} = require "child_process"
fs = require "fs"
{join, existsSync} = require "path"
watch = require "nodewatch"

DEST = "js/calculator.js"
SRCDIR = "src"

task "build", "build source and generate js files", (options)->
  srcs = []
  crawl SRCDIR, (filepath)->
    srcs.push filepath if filepath.match /[~#]*\.coffee$/
  exec "coffee -cj #{DEST} #{srcs.join ' '}", endwith (err, stdout, stderr)->
    console.log "built to '#{DEST}' successfully!" if stderr

task "clean", "delete a file that is generated by the build", (options)->
  exec "rm #{DEST}", endwith(->console.log "cleaned successfully!") if existsSync DEST

task "test", "validate src against tests", (options)->
  exec "mocha", endwith(->console.log "execute test suite!")

task "watch", "if there is a change in the folders [src, test], execute specs", (options)->
  console.log "start watching ..."
  watch.add("src").add("test").onChange (path, prev, curr)->
    console.log "detected changes on #{path}"
    doSerial(-> invoke "build")
    .with(-> invoke "test")
    .with(-> console.log "build end now").call()

# Generating function for the callback function at the time of completion exec
endwith = (yield_to)->
  return (err, stdout, stderr)->
    yield_to(err, stdout, stderr) if yield_to
    console.error err.message if err
    console.log stdout if stdout
    console.error stderr if stderr

# Function to perform the yield on the path to each directory argument, the following files by scanning the filepath
crawl = (filepath, yield_to) ->
  yield_to filepath
  if fs.lstatSync(filepath).isDirectory()
    files = (join(filepath, filename) for filename in fs.readdirSync(filepath))
    crawl(newpath, yield_to) for newpath in files

nextTick = (callback)->
  setTimeout callback, 0

# create an object in order to execute the specified function
doSerial = (f)->
  queue = [f]
  return {
  with: (f)->
    queue.push f
    this
  call: ->
    serialQueue = []
    queue.reverse()
    serializer = null
    for f, i in queue
      do (f, i) ->
        serialQueue.push ->
          proc = f()
          proc.on("exit", serialQueue.pop()) unless serialQueue.length <= 0
    queue.reverse()
    serialQueue.pop()()
  }
